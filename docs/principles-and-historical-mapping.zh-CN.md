# 《Great Ming》：以明代章奏与官僚流转重构的 Vibe Coding 工作流——原理与历史对应说明

## 摘要

“Vibe Coding”将软件工程的劳动过程叙事化与仪式化，以提升专注、降低心理阻力并增强人机协作的可解释性。《Great Ming》在不引入 MCP（Model Context Protocol）服务器的前提下，使用 Skill 与一组本地脚本，将“章奏—票拟—朱批—施行”的明代行政流转映射为“需求—方案—批准—执行”的工程闭环。本文说明该系统的设计原则、关键组件与历史制度对应关系，并讨论在脚本约束而非协议集成的条件下，如何尽可能获得“路由、权限、审计、复盘”的工程收益。

## 关键词

Vibe Coding；票拟；朱批；通政司；司礼监；六部；都察院；审计日志；Skill

## 一、引言：把工程闭环写成章奏流转

传统软件开发的“需求—实现—验证—交付”可以被视为一种行政流程：输入来自决策者，执行由官僚体系分工完成，而风险控制依赖审查与记录。《Great Ming》的动机并非复古表演，而是利用叙事框架为工程活动提供结构化输出与明确边界：当大型语言模型协助编写代码时，最常见的失败并非“不会写”，而是“写得太快、改得太多、缺乏批准与回溯”。因此，本项目以明代制度中的“票拟”作为默认的方案生成机制，以“朱批”作为人类批准的显式门槛，并以“司礼监记档”实现审计与可追溯性，从而将叙事沉浸感转化为工程可控性。

在技术路径上，本项目刻意选择 Skill + 本地脚本，而非 MCP Server。其原因在于：Skill 更接近“工作方法与文本协议”，可以快速传播与复用；脚本可以在不改变宿主工具能力边界的情况下，提供可靠的状态管理与日志落盘。相应的代价是：系统无法在协议层“新增工具/资源/提示集”，只能通过流程约束与脚本门面（wrapper）来实现近似的路由与权限控制。本文的讨论亦将围绕这一取舍展开。

## 二、制度对应：从通政司到司礼监的工程映射

明代章奏的经典流转可概括为“通政司收文→内阁票拟→司礼监传递→皇帝朱批→部院施行→科道监察”。《Great Ming》将其拆为六个工程构件，并为每一构件定义可执行的行为边界与可记录的产物。

首先，通政司在本系统中对应“意图路由器”。当用户提出需求时，系统不应立即进入代码修改，而应先判定紧急程度、文书类型与涉及部门：常规改造以题本呈报，线上灾异以奏本/塘报起手，Review/Debug/安全/性能问题以弹章纠弹，而执行过程的阶段回报则以揭帖短报承载。这一决策树被显式写入 `skills/great-ming/references/routing.md`，以减少模型在自由叙事下的漂移。

其次，内阁票拟对应“方案先行的工程说明书”。在题本/奏本/弹章结构中，“查得”承担证据与现状归纳，“臣惟”承担方案论证与风险评估，“拟”承担可执行的步骤清单。这一结构强迫系统把“推理”外显为“可审查的提案”，从而降低盲改与过度重构的概率。

再次，皇帝朱批在工程上对应“人类批准与范围授权”。历史上的朱批并不只是“同意/不同意”，还包含“该部知道”“再议具奏”“着九卿议”等指令，分别对应范围受限的执行、方案重拟与多方案会商。在本项目中，朱批解析规则被固化为分类器（见 `skills/great-ming/references/rescripts.md`），并进一步由脚本执行门面将其转化为可验证的授权边界。

司礼监在历史上掌印传批，亦可视为权力的“闸门”与“记录者”。《Great Ming》用 `mingctl` 脚本模拟这一层：在项目根目录创建 `.great-ming/`，并以追加写的 `archives.ndjson` 记录每次路由结果、朱批内容、命令执行及其退出码与耗时，同时以 `cases/` 与 `todo.md` 维护在办事项。这一“记档优先”的设计，使得“为何这么改”“是谁批准的”“执行过哪些命令”具备可追溯依据，尤其适用于多人协作或需要复盘的场景。

最后，六部与都察院分别对应“执行分工”与“监督审查”。六部在文本层提供隐喻分工，在执行层则映射为 Codex 的实际操作：工部对应文件修改（`apply_patch`），兵部对应命令/测试/构建（`shell_command`），礼部对应 lint/format/typecheck，刑部对应日志与复现追凶，吏部对应 git 取证与记录，户部对应资源与依赖清点。都察院的“纠弹”被用作一种结构化复核路径，要求在重大变更或高风险修复前给出反对意见与替代方案，从而在单 Agent 条件下模拟“集体决策”的约束效果。

## 三、实现机制：Skill 负责礼法，脚本负责闸门

《Great Ming》的实现分为两层：其一是 `skills/great-ming/SKILL.md` 及 `references/` 中的文本协议，负责规定称谓、文书体例、流程顺序与朱批口令；其二是 `skills/great-ming/scripts/mingctl.py`，负责把“朱批=授权”落到可执行的命令门面与审计日志。换言之，Skill 解决“怎么说、先说什么、何时请旨”，脚本解决“执行前是否被授权、执行后如何留档、如何汇总早朝议事”。

在数据结构上，`.great-ming/state.json` 记录默认礼仪严格度与当前案件编号，`.great-ming/cases/*.json` 记录案件的标题、状态与最近朱批，`.great-ming/archives.ndjson` 作为追加写审计流，适合用 `tail`、`jq` 或任意日志系统进行后续处理。选择 NDJSON 而非单一大 JSON 文件，源于工程上的可追加性与冲突友好性：即便多人并行操作，也可以用合并策略保留完整事件序列。

在权限边界上，`mingctl exec --kind action --dept <...>` 会检查“最近朱批”的类别：如拟则放行全部部门，该部知道则仅放行指定部门，览/留中/再议具奏/着九卿议则默认禁止执行，从而实现最小可行的“授权闸门”。这一机制并不等同于强制沙箱，因为模型仍可能绕过脚本直接调用宿主命令；但当团队约定“所有命令必须经 mingctl 执行并留档”时，它可以在流程层提供足够强的约束与复盘价值。

## 四、讨论：沉浸感、效率与可控性的平衡

叙事化工作流的首要风险在于成本：完整题本若每步都长篇铺陈，将显著消耗 token 并降低迭代速度。因此，本项目引入“礼仪严格度”与“揭帖”机制：在 `pragmatic`（简奏）模式下，保持称谓与结构但改用要点直陈，并将过程输出尽量压缩为揭帖短报，仅在关键节点（例如最终提交与发布）回归全礼题本，以兼顾效率与仪式感。

历史准确性与工程实用性之间亦存在张力。明代制度极其复杂，若完全复刻将导致使用门槛陡峭；因此《Great Ming》选择“抓住信息流的骨架”，而非复刻全部官制细节。通政司、内阁、司礼监与科道的对应关系，旨在把工程中最关键的三件事——路由、批准、审计——用稳定的叙事锚点固定下来。至于更细的宦官系统、廷议程序或各省清吏司的差异，则留作可选扩展，而非默认负担。

与 MCP 相比，脚本方案最大的缺口是“可发现性与强制集成”：MCP 可以把工具、资源与提示集注册为第一等对象，而脚本只能提供约定式入口。为了降低这一缺口，本文建议开源时把 `mingctl` 的命令设计保持稳定、输出保持可机器解析，并在 README 中明确推荐将 `.great-ming/` 加入目标项目的 `.gitignore`，从而让它成为可复制的团队规范，而不是一次性的个人仪式。

## 五、结论与展望

《Great Ming》证明了一种可行路径：在不扩展宿主协议（不引入 MCP Server）的前提下，仍可用 Skill 约束文本协议、用脚本落地状态与审计，将角色扮演从“装饰”转化为“工程治理”。未来工作可围绕三条主线展开：其一是新帝登基式 onboarding，使新用户在 30 秒内理解朱批口令与揭帖用法；其二是更强的“会商”机制，例如在“着九卿议”下引入固定的交叉审查清单；其三是面向发布与协作的仪式化工具，例如 ritual-commit 与 release memorial，使提交与发布具备同样可追溯的“圣旨链条”。

